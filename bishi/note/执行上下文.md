一、程序启动，全局上下文被创建

创建全局上下文的 词法环境
创建 对象环境记录器 ，它用来定义出现在 全局上下文 中的变量和函数的关系（负责处理 let 和 const 定义的变量）
创建 外部环境引用，值为 null


创建全局上下文的 变量环境
创建 对象环境记录器，它持有 变量声明语句 在执行上下文中创建的绑定关系（负责处理 var 定义的变量，初始值为 undefined 造成声明提升）
创建 外部环境引用，值为 null


确定 this 值为全局对象（以浏览器为例，就是 window ）


二、函数被调用，函数上下文被创建

创建函数上下文的 词法环境
创建  声明式环境记录器 ，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 let 和 const 定义的变量）
创建 外部环境引用，值为全局对象，或者为父级词法环境（作用域）


创建函数上下文的 变量环境
创建  声明式环境记录器 ，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 var 定义的变量，初始值为 undefined 造成声明提升）
创建 外部环境引用，值为全局对象，或者为父级词法环境（作用域）


确定 this 值


## 执行上下文
当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 "执行上下文(execution context 简称 EC)" 或者也可以叫做执行环境。
1. 代码分类(位置)
  * 全局代码
  * 函数(局部)代码
2. 全局执行上下文

  * 在执行全局代码前将window确定为全局执行上下文

  * 对全局数据进行预处理
    * var定义的全局变量==>undefined, 添加为window的属性
    * function声明的全局函数==>赋值(fun), 添加为window的方法
    * this==>赋值(window)指向全局执行上下文
  * 开始执行全局代码
3. 函数执行上下文

  * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)

  * 对局部数据进行预处理
    * 形参变量==>赋值(实参)==>添加为执行上下文的属性
    * arguments==>赋值(实参列表), 添加为执行上下文的属性
    * var定义的局部变量==>undefined, 添加为执行上下文的属性
    * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
    * this==>赋值(调用函数的对象)
  * 开始执行函数体代码

1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
3. 在函数执行上下文创建后, 将其添加到栈中(压栈)
4. 在当前函数执行完后,将栈顶的对象移除(出栈)
5. 当所有的代码执行完后, 栈中只剩下window

## 作用域
总结下来，能够使用的创建作用域的方式就两种：定义函数创建 和 let const 创建。

需要一组明确定义的规则，它定义了如何存储变量，以及如何找到这些变量。我们称这组规则为：作用域。

简单来说，作用域 指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。
全局作用域：全局作用域为程序的最外层作用域，一直存在。
函数作用域：函数作用域只有函数被定义时才会创建，包含在父级函数作用域 / 全局作用域内。

当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。

词法作用域（Lexical Scopes）是 javascript 中使用的作用域类型
javascript 中使用的是 “词法作用域”，因此函数作用域的范围在--函数定义--时就已经被确定，和函数在哪执行没有关系。

作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突

1. 区别1
  * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时

  * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建

  * 函数执行上下文是在调用函数时, 函数体代码执行之前创建

2. 区别2
  * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
  * 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放
3. 联系
  * 执行上下文(对象)是从属于所在的作用域
  * 全局上下文环境==>全局作用域
  * 函数上下文环境==>对应的函数使用域

## es5 词法环境和变量环境
在词法环境的内部有两个组件：(1) 环境记录器和 (2) 一个外部环境的引用。

环境记录器是存储变量和函数声明的实际位置。（作用域）
外部环境的引用意味着它可以访问其父级词法环境。

环境记录器也有两种类型：
在全局环境中，环境记录器是对象环境记录器。
在函数环境中，环境记录器是声明式环境记录器。

变量环境 它也是一个 词法环境 ，所以它有着词法环境的所有特性。

词法环境组件和 变量环境 的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。

## 总结
创建全局执行上下文，let const class声明的类存储在词法环境的对象环境记录器里，未初始化值，var 与函数声明存储在变量环境的对象环境记录器中，var初始化为underfind

变量先在词法环境找，未找到在变量环境里找变量环境里找

特殊：块中声明的函数，也有函数提升，值为underfind，当执行完块中代码将会赋值给全局对象（对象环境记录器）