console.log(quickSort([2,3,1,7,5,10,9]))
(function () {
var x = y = 1
})()
console.log(y)

var name = 'word'
(function () {
if (typeof name === 'undefined') {
console.log(111)
} else {
console.log(222)
}
}())

console.log([3<2<1,1<2<3])

## DIV+CSS 布局和 TABLE 布局的优缺点 1.代码结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。

2..布局精准，网站版面布局修改简单。 3.加快了页面的加载速度 4.用只包含结构化内容的 HTML 代替嵌套的标签，提高另外搜索引擎对网页的搜索效率。

## 什么是 Canvas？

Canvas 是 H5 新出来的标签
Canvas 画布，利用 JavaScript 在网页绘制图像

## 什么是 SVG？

SVG 可缩放矢量图形（Scalable Vector Graphics），基于可扩展标记语言 XML 出来的时间比较老
SVG 用来定义用于网格的基于矢量的图形

Canvas 和 SVG 区别:  
1.绘制的图片格式不同  
Canvas 的工具 getContext 绘制出来的图形或传入的图片都依赖分辨率，能够以 png 和 .jpg 格式保存存储图像，可以说是位图
SVG 可以在 H5 中直接绘制，但绘制的是矢量图

2.Canvas 不支持事件处理器，SVG 支持事件处理器
Canvas 绘制的图像 都在 Canvas 这个画布里面，是 Canvas 的一部分，不能用 js 获取已经绘制好的图形元素。
而 SVG 绘图时，每个图形都是以 DOM 节点的形式插入到页面中，可以用 js 或其他方法直接操作

3.适用范围不同
Canvas 的文本渲染能力弱，而 SVG 最适合带有大型渲染区域的应用程序，比如地图。

而 Canvas 最适合有许多对象要被频繁重绘的图形密集型游戏。

而 SVG 由于 DOM 操作 在复杂度高的游戏应用中 会减慢渲染速度。所以不适合在游戏应用。

## 什么是响应式 Web 设计?

网页可以在任何设备上展示和操作，设备包括桌面系统设备，平板电脑，iPhone 等手机等。网页应该根据设备的大小自动调整内容。

## 事件委托(委派/代理):

将多个子元素(li)的事件监听委托给父辈元素(ul)处理
监听回调是加在了父辈元素上
事件会冒泡到父辈元素(ul)
父辈元素不会直接处理事件, 而是根据 event.target 得到发生事件的子元素(li), 通过这个子元素调用事件回调函数

## 使用事件委托的好处

添加新的子元素, 自动有事件响应处理
减少事件监听的数量

## 事件轮询机制

js 是单线程的，所以也可以叫主线程，js 代码都是在主线程上运行的，区分同步执行和异步执行，当代码是异步，对应回调函数，不同的回调交给不同的模块管理，比如定时器模块，网络请求模块，事件处理模块，回调什么时候执行，取决于模块什么时候将回调放入到事件队列里边，js 引擎会通过轮询的方式去询问队列是否有可执行的回调，如果有就会将这个函数勾出去，勾到主线程上执行

# webpack 性能优化

- 开发环境性能优化
- 生产环境性能优化

## 开发环境性能优化

- 优化打包构建速度
  - HMR
- 优化代码调试
  - source-map

## 生产环境性能优化

- 优化打包构建速度
  - oneOf
  - babel 缓存
  - 多进程打包
  - externals
  - dll
- 优化代码运行的性能
  - 缓存(hash-chunkhash-contenthash)
  - tree shaking
  - code split
  - 懒加载/预加载
  - pwaack

## BFC

全称：Block Formatting Context， 名为 "块级格式化上下文"。
是一个完全独立的空间,让空间里的!!!子!!!元素不会影响到外面的布局。
overflow: hidden
display: inline-block
position: absolute
position: fixed
display: table-cell
display: flex
因为 BFC 内部的元素和外部的元素不会互相影响，因此当 BFC 外部存在浮动时，它不应该影响 BFC 内部 box 的布局，BFC 会通过变窄而不与浮动 box 有重叠。 同样的，当 BFC 内部有浮动时，为了不影响外部元素的布局，BFC 计算高度时会包括浮动 box 的高度，避免 margin 重叠也是一样的道理。

## BFC 解决了什么问题

高度塌陷
Margin 边距重叠
两栏布局

## 内存溢出

- 一种程序运行出现的错误
- 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误

## 内存泄露

- 占用的内存没有及时释放
- 内存泄露积累多了就容易导致内存溢出
- 常见的内存泄露:
  - 意外的全局变量
  - 没有及时清理的计时器或回调函数
  - 闭包

## 闭包

如何产生闭包?

- 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包

能够访问其他函数内部变量的函数，被称为 闭包。
闭包就是函数内部定义的函数，被返回了出去并在外部调用。

一个函数请用另一个函数作用域的变量

常见闭包
将函数作为另一个函数的返回值
将函数作为实参传递给另一个函数调用

闭包作用

<!--
1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

问题:
  1. 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭中的变量才可能存在
  2. 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它
-->

## js 闭包应用--自定义 JS 模块

具有特定功能的 js 文件
将所有的是数据和功能都封装在一个函数体内部
模块的使用者只需要通过模块暴露的对象调用方法来实现对应的功能
## undefined 与 null 的区别?

- undefined 代表定义未赋值
- nulll 定义并赋值了, 只是值为 null

什么时候给变量赋值为 null 呢?

- 初始赋值, 表明将要赋值为对象
- 结束前, 让对象成为垃圾对象(被垃圾回收器回收)

## HTML 常见的行内(块)元素

<span>、<a>、 <img>、 <input>、<textarea>、<select>、<label>

<div>、<table>、<form>、<p>、<ul>

## flex

弹性容器
flex-direction 指定容器中弹性元素的排列方式
flex-wrap: 设置弹性元素是否在弹性容器中自动换行
justify-content 如何分配主轴上的空白空间
align-items: 元素在辅轴上如何对齐
align-content 辅轴空白空间的分布

弹性元素
flex-grow 弹性的增长系数
flex-shrink 弹性元素的缩减系数
flex-basis 指定的是元素在主轴上的基础长度

## animation

animation-name: 要对当前元素生效的关键帧的名字
animation-delay: 动画的延时
animation-iteration-count 动画执行的次数
animation-timing-function: ease-in-out;时序函数
animation-fill-mode: 动画的填充模式
animation-direction 指定动画运行的方向
animation-play-state: 设置动画的执行状态

## transform

translate 平移， z 轴平移属于立体效果（近大远小），默认情况下网页是不支持透视，如果需要看见效果，必须要设置网页的视距

rotate 旋转

scale 缩放

## background

background-image 设置背景图片

- 可以同时设置背景图片和背景颜色，这样背背景色
- 如果背景的图片小于元素，则背景图片会自铺满
- 如果背景的图片大于元素，将会一个部分背景无法完全显示
- 如果背景图片和元素一样大，则会直接正常显示

background-image: url("./img/1.png")

background-repeat 用来设置背景的重复方式
background-clip 设置背景的范围
background-size 设置背景图片的大小
background-position 用来设置背景图片的位置 使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是 center
background-origin 背景图片的偏移量计算的原点
background-attachment 背景图片是否跟随元素移动

## this

this 对象是在运行的时候基于函数的执行环境绑定（调用位置）的

this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象

如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象

匿名函数的执行环境具有全局性(箭头函数在定义是确定this)，因此其this对象通常指向window。

new 一个实例的执行流程  
 1.创建一个新的对象  
 2.将新的对象作为函数的上下文对象（this）  
 3.执行函数中的代码  
 4.将新建的对象返回

## 完美视口 设备独立像素 物理像素

视口： 网页的视口
完美视口： 让视口等于设备独立像素
像素比： 物理像素/设备独立像素

小程序适配方案：规定任何屏幕下宽度为 750rpx
Iphone6 下： 1rpx = 1 物理像素 = 0.5px

## SPA(单页面应用)

就是指一个系统只加载一次资源，之后的操作交互、数据交互是通过路由、ajax 来进行，页面并没有刷新。

## 箭头函数
箭头函数的this是在定义函数的时候绑定的，而不是在执行函数的时候绑定的

箭头函数没有 this
无 new，不能当作构造函数
无 arguments，可以通过剩余运算符获取
没有函数提升
不能用 call 和 apply 绑定

## 变量提升与函数提升
函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖



