console.log(quickSort([2,3,1,7,5,10,9]))
(function () {
var x = y = 1
})()
console.log(y)

var name = 'word'
(function () {
if (typeof name === 'undefined') {
console.log(111)
} else {
console.log(222)
}
}())

console.log([3<2<1,1<2<3])

## DIV+CSS 布局和 TABLE 布局的优缺点 1.代码结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。

2..布局精准，网站版面布局修改简单。 3.加快了页面的加载速度 4.用只包含结构化内容的 HTML 代替嵌套的标签，提高另外搜索引擎对网页的搜索效率。

## 什么是 Canvas？

Canvas 是 H5 新出来的标签
Canvas 画布，利用 JavaScript 在网页绘制图像

## 什么是 SVG？

SVG 可缩放矢量图形（Scalable Vector Graphics），基于可扩展标记语言 XML 出来的时间比较老
SVG 用来定义用于网格的基于矢量的图形

Canvas 和 SVG 区别:  
1.绘制的图片格式不同  
Canvas 的工具 getContext 绘制出来的图形或传入的图片都依赖分辨率，能够以 png 和 .jpg 格式保存存储图像，可以说是位图
SVG 可以在 H5 中直接绘制，但绘制的是矢量图

2.Canvas 不支持事件处理器，SVG 支持事件处理器
Canvas 绘制的图像 都在 Canvas 这个画布里面，是 Canvas 的一部分，不能用 js 获取已经绘制好的图形元素。
而 SVG 绘图时，每个图形都是以 DOM 节点的形式插入到页面中，可以用 js 或其他方法直接操作

3.适用范围不同
Canvas 的文本渲染能力弱，而 SVG 最适合带有大型渲染区域的应用程序，比如地图。

而 Canvas 最适合有许多对象要被频繁重绘的图形密集型游戏。

而 SVG 由于 DOM 操作 在复杂度高的游戏应用中 会减慢渲染速度。所以不适合在游戏应用。

## 什么是响应式 Web 设计?

网页可以在任何设备上展示和操作，设备包括桌面系统设备，平板电脑，iPhone 等手机等。网页应该根据设备的大小自动调整内容。

## 事件委托(委派/代理):

将多个子元素(li)的事件监听委托给父辈元素(ul)处理
监听回调是加在了父辈元素上
事件会冒泡到父辈元素(ul)
父辈元素不会直接处理事件, 而是根据 event.target 得到发生事件的子元素(li), 通过这个子元素调用事件回调函数

## 使用事件委托的好处

添加新的子元素, 自动有事件响应处理
减少事件监听的数量

## 事件轮询机制

js 是单线程的，所以也可以叫主线程，js 代码都是在这条单线程上运行的，区分同步执行和异步执行，当代码是异步，对应回调函数，不同的回调交给不同的模块管理，比如定时器模块，网络请求模块，事件处理模块，回调什么时候执行，取决于模块什么时候将回调放入到事件队列里边，js 引擎会通过轮询的方式去询问队列是否有可执行的回调，如果有就会将这个函数勾出去，勾到主线程上执行

js是单线程语言，它的异步和多线程是通过evnet loop事件循环机制实现的，大体由三部分组成，调用栈，消息队列，微任务队列。event loop开始时会从全局代码一行行开始执行，遇到函数调用，会把它压入调用栈中执行，当函数执行完从执行栈会从执行栈中弹出，js中的异步操作，比如fetch，事件回调，settimeout会交给不同的模块管理，模块会把任务交给消息队列，当调用栈空了，js 引擎会通过轮询的方式去询问队列是否有可执行的回调，如果有将压入栈中执行，函数执行完从执行栈会从执行栈中弹出，使用promise.then和async创建的异步操作，会加入到微任务队列中

执行宏任务，微任务，渲染页面，执行下一个宏任务

执行一个宏任务（栈中没有就从事件队列中获取）
执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）
    
先执行同步代码，遇到函数调用，把它压入执行栈，执行完后弹出
# webpack 性能优化

- 开发环境性能优化
- 生产环境性能优化

## 开发环境性能优化

- 优化打包构建速度
  - HMR
- 优化代码调试
  - source-map

## 生产环境性能优化

- 优化打包构建速度
  - oneOf
  - babel 缓存
  - 多进程打包
  - externals
  - dll
- 优化代码运行的性能
  - 缓存(hash-chunkhash-contenthash)
  - tree shaking
  - code split
  - 懒加载/预加载
  - pwaack

## BFC

全称：Block Formatting Context， 名为 "块级格式化上下文"。
是一个完全独立的空间,让空间里的!!!子!!!元素不会影响到外面的布局。
overflow: hidden
display: inline-block
position: absolute
position: fixed
display: table-cell
display: flex
因为 BFC 内部的元素和外部的元素不会互相影响，因此当 BFC 外部存在浮动时，它不应该影响 BFC 内部 box 的布局，BFC 会通过变窄而不与浮动 box 有重叠。 同样的，当 BFC 内部有浮动时，为了不影响外部元素的布局，BFC 计算高度时会包括浮动 box 的高度，避免 margin 重叠也是一样的道理。

## BFC 解决了什么问题

高度塌陷
Margin 边距重叠
两栏布局

## 内存溢出

- 一种程序运行出现的错误
- 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误

## 内存泄露

- 占用的内存没有及时释放
- 内存泄露积累多了就容易导致内存溢出
- 常见的内存泄露:
  - 意外的全局变量
  - 没有及时清理的计时器或回调函数
  - 闭包

## 闭包

如何产生闭包?

- 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包

能够访问其他函数内部变量的函数，被称为 闭包。
闭包就是函数内部定义的函数，被返回了出去并在外部调用。

一个函数请用另一个函数作用域的变量

常见闭包
将函数作为另一个函数的返回值
将函数作为实参传递给另一个函数调用

闭包作用

<!--
1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

问题:
  1. 函数执行完后, 函数内部声明的局部变量是否还存在?  一般是不存在, 存在于闭中的变量才可能存在
  2. 在函数外部能直接访问函数内部的局部变量吗? 不能, 但我们可以通过闭包让外部操作它
-->

1. 缺点
  * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
  * 容易造成内存泄露
2. 解决
  * 能不用闭包就不用
  * 及时释放

## js 闭包应用--自定义 JS 模块

具有特定功能的 js 文件
将所有的是数据和功能都封装在一个函数体内部
模块的使用者只需要通过模块暴露的对象调用方法来实现对应的功能
## undefined 与 null 的区别?

- undefined 代表定义未赋值，希望表示一个变量最原始的状态，而非人为操作的结果 。（变量没有被赋值，则会返回undefined）
- nulll 定义并赋值了, 只是值为 null，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。（变量未指向任何对象,把 null 作为尚未创建的对象）

如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null
当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用

什么时候给变量赋值为 null 呢?

- 初始赋值, 表明将要赋值为对象
- 结束前, 让对象成为垃圾对象(被垃圾回收器回收)

## HTML 常见的行内(块)元素

<span>、<a>、 <img>、 <input>、<button>、<textarea>、<select>、<label>

<div>、<table>、<form>、<p>、<ul>、<h1>

## flex

弹性容器
flex-direction 指定容器中弹性元素的排列方式
flex-wrap: 设置弹性元素是否在弹性容器中自动换行
justify-content 如何分配主轴上的空白空间
align-items: 元素在辅轴上如何对齐
align-content 辅轴空白空间的分布

弹性元素
flex-grow 弹性的增长系数
flex-shrink 弹性元素的缩减系数
flex-basis 指定的是元素在主轴上的基础长度

## animation

animation-name: 要对当前元素生效的关键帧的名字
animation-delay: 动画的延时
animation-iteration-count 动画执行的次数
animation-timing-function: ease-in-out;时序函数
animation-fill-mode: 动画的填充模式
animation-direction 指定动画运行的方向
animation-play-state: 设置动画的执行状态

## transform

translate 平移， z 轴平移属于立体效果（近大远小），默认情况下网页是不支持透视，如果需要看见效果，必须要设置网页的视距

rotate 旋转

scale 缩放

## background

background-image 设置背景图片

- 可以同时设置背景图片和背景颜色，这样背背景色
- 如果背景的图片小于元素，则背景图片会自铺满
- 如果背景的图片大于元素，将会一个部分背景无法完全显示
- 如果背景图片和元素一样大，则会直接正常显示

background-image: url("./img/1.png")

background-repeat 用来设置背景的重复方式
background-clip 设置背景的范围
background-size 设置背景图片的大小
background-position 用来设置背景图片的位置 使用方位词时必须要同时指定两个值，如果只写一个则第二个默认就是 center
background-origin 背景图片的偏移量计算的原点
background-attachment 背景图片是否跟随元素移动

## this

this 对象是在运行的时候基于函数的执行环境绑定（调用位置）的

this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象

如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象

匿名函数的执行环境具有全局性(箭头函数在定义是确定this)，因此其this对象通常指向window。

new 一个实例的执行流程  
 1.创建一个新的对象  
 2.将新的对象作为函数的上下文对象（this）  
 3.执行函数中的代码  
 4.将新建的对象返回

## 完美视口 设备独立像素 物理像素
默认情况下，移动端的网页都会将视口设置为980像素（css像素）
以确保pc端网页可以在移动端正常访问，但是如果网页的宽度超过了980，
移动端的浏览器会自动对网页缩放以完整显示网页 

物理像素/视口/设计图大小

视口： 网页的视口(iphone6完美视口375px css) 物理像素750，放大两倍
完美视口： 让视口等于设备独立像素
像素比： 物理像素/设备独立像素

小程序适配方案：规定任何屏幕下宽度为 750rpx
Iphone6 下： 1rpx = 1 物理像素 = 0.5px

## SPA(单页面应用)

就是指一个系统只加载一次资源，之后的操作交互、数据交互是通过路由、ajax 来进行，页面并没有刷新。

## 箭头函数
箭头函数的this是在定义函数的时候绑定的，而不是在执行函数的时候绑定的

箭头函数没有 this
无 new，不能当作构造函数
无 arguments，可以通过剩余运算符获取
没有函数提升
不能用 call 和 apply 绑定

## 变量提升与函数提升
函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖

1. 变量声明提升
  * 通过var定义(声明)的变量, 在定义语句之前就可以访问到
  * 值: undefined
2. 函数声明提升
  * 通过function声明的函数, 在之前就可以直接调用
  * 值: 函数定义(对象)

被赋值变量的优先级 > 函数优先级 > 函数参数 > 变量优先级

## url
1.DNS解析，将域名地址解析为ip地址
  -浏览器dns缓存
  系统DNS缓存
  路由器DNs缓存
  网络运营商DNS缓存
  递归搜索：域名

2.TCP连接。TCP三次握手

3.发送请求

4.接收响应

5.渲染页面

6.断开连接，TCP四次挥手

## for of   for in
使用for-in可以遍历数组，但是会存在以下问题：
1.index索引为字符串型数字（注意，非数字），不能直接进行几何运算。
2.遍历顺序有可能不是按照实际数组的内部顺序（可能按照随机顺序）。
3.使用for-in会遍历数组所有的可枚举属性，包括原型。例如上例的原型方法method和name属性都会被遍历出来，通常需要配合hasOwnProperty()方法判断某个属性是否该对象的实例属性，来将原型对象从循环中剔除。

for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象.与forEach()不同的是，它可以正确响应break、continue和return语句
for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法

简单总结就是，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值

## 事件冒泡 事件捕获
事件冒泡；事件会从最内层的元素开始发生，一直向上传播，直到document对象。
事件捕获；事件会从最外层开始发生，直到最具体的元素

## 构造函数继承与原型链继承
借用构造函数继承：在子类的构造函数中执行父类的构造函数,并且为其绑定类的this
缺点：只能继承父类的实例属性和方法，不能继承原型属性/方法

原型链继承：使子类构造函数的原型的原型指向父类原型（子类原型为父类的实例），父类中的this指向子类原型
缺点：多个实例对引用类型的操作会被篡改。(父类的this上属性和方法会添加到子类的原型上)

组合式:
缺点：使用子类创建实例对象时，其子类实例和原型中会存在两份相同的属性/方法。

原型式继承：利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。
缺点：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能

寄生式继承：在原型式继承的基础上，增强对象，返回构造函数
缺点：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。无法传递参数

寄生组合式继承:结合借用构造函数传递参数和寄生模式实现继承

## 原型
引用类型，都有一个隐式原型 __proto__ 属性，属性值是一个普通的对象。
引用类型，隐式原型 __proto__ 的属性值指向它的构造函数的显式原型 prototype 属性值。
每个函数function都有一个prototype，即显式原型(属性)
每个实例对象都有一个__proto__，可称为隐式原型(属性)
 *****如果b的显示原型在对象a的隐式原型链上，返回true

  * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个Object的实例对象
    
  1.Objec的显示原型为Object的实例对象,它的隐式原型为null。Object函数的隐式原型为Funciton的显示原型
  2.所有函数都是Function的实例(函数的隐式原型等于Function的显示原型)
  3.Fuction.prototype = Fution.__protp__

  [[Prototype]]: Object的J__protp__指回第一个[[Prototype]]

  * 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值
  * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)

  构造(普通)函数的显示原型为空对象，隐式原型指向Function的构造函数

总结：先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生。

## 清除浮动
1. 利用clear样式 （设置清除浮动以后，浏览器会自动为元素添加一个上外边距，）
2. 父元素结束标签之前插入清除浮动的块级元素
3. 利用伪元素（clearfix）父元素加上
4. 利用overflow清除浮动


## 回流 重绘
回流：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

页面首次渲染
浏览器窗口大小发生改变
元素尺寸或位置发生改变
元素内容变化（文字数量或图片大小等等）
元素字体大小变化
添加或者删除可见的DOM元素
激活CSS伪类（例如：:hover）
查询某些属性或调用某些方法

重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

1.避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。（classList、cssText）
2.避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
3.也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
4.对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

## 用CSS实现三角符号
盒子宽高均为零，三面边框皆透明

## 页面布局
1.Flex 布局
2.Rem 布局(Rem 相对于根(html)的 font-size 大小来计算。)
3.浮动布局
4.position
## 数组去重
set
for两次循环
filter indexOf

## es6
var 变量提升 变量覆盖 没有块级作用域

let let声明的变量只在其声明的块或子块中可用 不能重复声明 未初始化前不能使用,let声明的变量直到它们的定义被执行时才初始化 

const 声明之后必须赋值  定义的值不能修改  

可选链操作符?. 空值合并操作符??

Object.entries(转换二维)   Object.fromEntries(一维对象)

Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

reduce数组扁平化

map reduce foreach filter includes
## 响应式布局
响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。
响应式布局就是根据屏幕大小变化，页面的内容排版布局会自动调整变动，已呈现更好的用户体

1. 媒体查询
float布局

自适应布局
自适应布局就是宽度自适用布局，在不同大小的设备上，网页以等比例的形式缩放宽度，呈现同样的主体内容和排版布局
2.百分比布局
3.rem布局
4.视口单位(vw表示相对于视图窗口的宽度)
  1.仅使用vw作为CSS单位
  2.搭配vw和rem

## 模糊效果
阴影的模糊半径
背景渐变效果
filter属性

## 行内元素 块元素
行内元素的宽高由内容决定，

块级元素可以设置宽高，独占一行

## 优化
防抖 图片懒加载 去除 console.log 去除 SourceMap CDN减少打包体积(externals)  骨架屏

减少http请求（精灵图） 使用字体图标 iconfont 代替图片图标 elementui按需加载

使用事件委托 路由懒加载  开启gzip压缩减小文件体积，使传输速度更快（注册中间件）

## ES6 模块与 CommonJS 模块
① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。